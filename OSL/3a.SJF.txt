#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>

using namespace std;

struct Process {
    int id;
    int arrival_time;
    int burst_time;
    int remaining_time;
    int completion_time;
    int start_time;
    int turnaround_time;
    int waiting_time;
};

struct CompareArrivalTime {
    bool operator()(const Process& p1, const Process& p2) {
        return p1.arrival_time > p2.arrival_time;
    }
};

int main() {
    int n;
    cout << "Enter the number of processes: ";
    cin >> n;
    vector<Process> processes(n);

    for (int i = 0; i < n; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process P" << i + 1 << ": ";
        cin >> processes[i].arrival_time;
        cout << "Enter burst time for process P" << i + 1 << ": ";
        cin >> processes[i].burst_time;
        processes[i].remaining_time = processes[i].burst_time;
        processes[i].completion_time = 0;
        processes[i].start_time = -1;
    }

    int currentTime = 0;
    int completed = 0;
    vector<int> executionOrder;
    priority_queue<Process, vector<Process>, CompareArrivalTime> readyQueue;

    while (completed < n) {
        for (int i = 0; i < n; i++) {
            if (processes[i].arrival_time <= currentTime && processes[i].remaining_time > 0) {
                readyQueue.push(processes[i]);
            }
        }

        if (!readyQueue.empty()) {
            Process shortestJob = readyQueue.top();
            readyQueue.pop();

            int shortestIndex = shortestJob.id - 1;
            if (processes[shortestIndex].start_time == -1) {
                processes[shortestIndex].start_time = currentTime;
            }

            processes[shortestIndex].remaining_time--;
            currentTime++;

            if (processes[shortestIndex].remaining_time == 0) {
                completed++;
                int completionTime = currentTime;
                processes[shortestIndex].completion_time = completionTime;
                executionOrder.push_back(shortestIndex);
            }
        } else {
            currentTime++;
        }
    }

    cout << "Execution Gantt Chart:" << endl;
    int prevCompletionTime = 0;
    for (int i = 0; i < executionOrder.size(); i++) {
        int index = executionOrder[i];
        cout << "P" << processes[index].id << " | ";
        prevCompletionTime = processes[index].completion_time;
    }
    cout << endl;

    float totalTurnaroundTime = 0;
    float totalWaitingTime = 0;
    for (int i = 0; i < n; i++) {
        processes[i].turnaround_time = processes[i].completion_time - processes[i].arrival_time;
        processes[i].waiting_time = processes[i].turnaround_time - processes[i].burst_time;
        totalTurnaroundTime += processes[i].turnaround_time;
        totalWaitingTime += processes[i].waiting_time;
    }

    float averageTurnaroundTime = totalTurnaroundTime / n;
    float averageWaitingTime = totalWaitingTime / n;

    cout << "Average Turnaround Time: " << averageTurnaroundTime << endl;
    cout << "Average Waiting Time: " << averageWaitingTime << endl;

    return 0;
}
